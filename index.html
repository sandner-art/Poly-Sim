<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://unpkg.com/gpu.js@latest/dist/gpu-browser.min.js" defer></script>
    <title>Poly-Sim: Self-Organizing Networks</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { background: #000; font-family: 'Arial', sans-serif; overflow: hidden; touch-action: none; -webkit-tap-highlight-color: transparent; }
        canvas { display: block; cursor: crosshair; touch-action: none; }
        .ui-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none; z-index: 100; }
        .controls { position: absolute; bottom: 20px; left: 20px; right: 20px; background: rgba(0, 0, 0, 0.95); padding: 20px; border-radius: 15px; color: white; backdrop-filter: blur(15px); border: 1px solid rgba(255, 255, 255, 0.15); transition: all 0.3s ease; pointer-events: auto; max-height: 70vh; overflow-y: auto; touch-action: auto; z-index: 100;}
        .controls.collapsed { transform: translateY(calc(100% - 60px)); }
        .controls-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; cursor: pointer; padding: 5px; border-radius: 8px; transition: background 0.3s ease; }
        .controls-header:hover { background: rgba(255, 255, 255, 0.05); }
        .controls-header h3 { margin: 0; font-size: 18px; display: flex; align-items: center; gap: 10px; }
        .gpu-indicator { padding: 2px 8px; border-radius: 12px; font-size: 10px; font-weight: bold; }
        .gpu-indicator.gpu-on { background: rgba(76, 175, 80, 0.3); border: 1px solid rgba(76, 175, 80, 0.5); color: #4CAF50; }
        .gpu-indicator.gpu-off { background: rgba(255, 152, 0, 0.3); border: 1px solid rgba(255, 152, 0, 0.5); color: #FF9800; }
        .toggle-btn { width: 30px; height: 30px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 50%; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; transition: all 0.3s ease; }
        .header-buttons { display: flex; align-items: center; gap: 10px; pointer-events: auto; z-index: 1; }
        .header-buttons .toggle-btn { pointer-events: auto; }
        .toggle-btn svg { width: 18px; height: 18px; fill: white; display: block; }
        .toggle-btn:hover { background: rgba(255, 255, 255, 0.2); transform: scale(1.05); }
        .controls-content { transition: opacity 0.3s ease, max-height 0.3s ease; overflow: hidden; }
        .controls.collapsed .controls-content { opacity: 0; max-height: 0; }
        .section { margin-bottom: 20px; padding: 15px; background: rgba(255, 255, 255, 0.03); border-radius: 10px; border: 1px solid rgba(255, 255, 255, 0.05); }
        .section-title { font-size: 14px; font-weight: bold; margin-bottom: 12px; opacity: 0.9; display: flex; align-items: center; gap: 8px; }
        .preset-selector { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px; }
        .preset-btn { padding: 10px 8px; background: rgba(255, 255, 255, 0.08); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 8px; color: white; cursor: pointer; transition: all 0.3s ease; text-align: center; font-size: 12px; font-weight: bold; }
        .preset-btn:hover { background: rgba(255, 255, 255, 0.15); transform: translateY(-1px); }
        .preset-btn.active { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(100, 200, 255, 0.4); }
        .preset-btn.physarum.active { background: rgba(100, 255, 100, 0.2); border-color: rgba(100, 255, 100, 0.4); }
        .preset-btn.plasma.active { background: rgba(100, 150, 255, 0.2); border-color: rgba(100, 150, 255, 0.4); }
        .preset-btn.neural.active { background: rgba(0, 255, 255, 0.2); border-color: rgba(0, 255, 255, 0.4); }
        .preset-btn.scientific.active { background: rgba(255, 165, 0, 0.2); border-color: rgba(255, 165, 0, 0.4); }
        .color-mode-selector { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-bottom: 12px; }
        .color-mode-btn { padding: 6px 4px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 6px; color: white; cursor: pointer; transition: all 0.3s ease; text-align: center; font-size: 10px; }
        .color-mode-btn.active { background: rgba(255, 165, 0, 0.3); border-color: rgba(255, 165, 0, 0.5); }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 11px; opacity: 0.9; }
        .slider { width: 100%; height: 4px; background: rgba(255, 255, 255, 0.15); border-radius: 2px; outline: none; -webkit-appearance: none; appearance: none; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: #fff; border-radius: 50%; cursor: pointer; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3); }
        .slider::-moz-range-thumb { width: 16px; height: 16px; background: #fff; border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3); }
        .checkbox-group { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .checkbox-group input[type="checkbox"] { width: 16px; height: 16px; }
        .checkbox-group label { font-size: 11px; margin: 0; }
        .button-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px; }
        .button-grid.three-col { grid-template-columns: repeat(3, 1fr); }
        .action-btn { padding: 10px 8px; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: white; cursor: pointer; text-align: center; font-size: 11px; font-weight: bold; transition: all 0.3s ease; text-transform: uppercase; }
        .action-btn:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3); }
        .reset-btn { background: rgba(255, 100, 100, 0.2); border-color: rgba(255, 100, 100, 0.4); }
        .pause-btn { background: rgba(255, 200, 100, 0.2); border-color: rgba(255, 200, 100, 0.4); }
        .maze-btn { background: rgba(150, 100, 255, 0.2); border-color: rgba(150, 100, 255, 0.4); }
        .file-input-wrapper { position: relative; margin-bottom: 8px; }
        .file-input { position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer; }
        .file-input-display { padding: 8px 12px; background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 6px; font-size: 10px; text-align: center; cursor: pointer; transition: all 0.3s ease; }
        .file-input-display:hover { background: rgba(255, 255, 255, 0.1); }
        .info-panel { position: absolute; top: 20px; left: 20px; right: 20px; background: rgba(0, 0, 0, 0.85); padding: 15px; border-radius: 10px; color: white; font-size: 12px; text-align: center; border: 1px solid rgba(255, 255, 255, 0.1); pointer-events: auto; transition: opacity 0.3s ease; }
        .info-panel.hidden { opacity: 0; pointer-events: none; }
        .fps-counter { position: absolute; top: 20px; right: 20px; background: rgba(0, 0, 0, 0.8); color: white; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 11px; pointer-events: auto; border: 1px solid rgba(255, 255, 255, 0.1); }
        .version-info { text-align: center; padding: 12px; font-size: 10px; opacity: 0.6; border-top: 1px solid rgba(255, 255, 255, 0.1); margin-top: 15px; }
        .version-info a { color: #64B5F6; text-decoration: none; }
        .version-info a:hover { text-decoration: underline; }

/* Style for the main dropdown box itself */
#initPattern, #firingMode {
    width: 100%;
    padding: 8px;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 6px;
    color: white;
    cursor: pointer;
    /* Remove the default OS dropdown arrow */
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    /* Add our own custom arrow that fits the dark theme */
    background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23FFFFFF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
    background-repeat: no-repeat;
    background-position: right 10px center;
    background-size: 10px;
}

/* Style for the individual options in BOTH dropdown lists */
#initPattern option, #firingMode option {
    background: #1c1c1e; /* A dark background for the options list */
    color: #eee;       /* A light text color for readability */
}

/* Optional: A subtle hover effect for the options in BOTH lists */
#initPattern option:hover, #firingMode option:hover {
    background: rgba(100, 150, 255, 0.3);
}

/* This is the key part: Style for the individual options in the list */
#initPattern option {
    background: #1c1c1e; /* A dark background for the options list */
    color: #eee;       /* A light text color for readability */
}

/* Optional: Add a subtle hover effect for the options */
#initPattern option:hover {
    background: rgba(100, 150, 255, 0.3);
}        
        #analyticsCanvas { position: fixed; bottom: 20px; right: 20px; width: 250px; height: 120px; background: rgba(0,0,0,0.85); border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; pointer-events: none; opacity: 0; transition: opacity 0.3s ease; z-index: 99; }
        #analyticsCanvas.visible { opacity: 1; pointer-events: auto; }
        #graphToggleBtn { position: fixed; top: 60px; right: 20px; width: 35px; height: 35px; background: rgba(0,0,0,0.8); color: white; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; z-index: 101; }
        #graphToggleBtn svg { width: 20px; height: 20px; fill: white; }
        @media (max-width: 600px) {
            .controls { left: 10px; right: 10px; bottom: 10px; padding: 15px; }
            .info-panel { left: 10px; right: 10px; top: 10px; }
            .preset-selector, .color-mode-selector { grid-template-columns: repeat(2, 1fr); }
            #analyticsCanvas { left: 10px; right: 10px; width: auto; }
        }
        @media (orientation: landscape) and (max-height: 500px) {
            .controls { max-height: 80vh; left: 10px; right: 300px; }
            .fps-counter { right: 10px; }
            #graphToggleBtn { right: 10px; }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <canvas id="analyticsCanvas"></canvas>
    <div id="graphToggleBtn" title="Toggle Analytics Graph">
        <svg viewBox="0 0 24 24"><path d="M16 11.76l-1.41-1.41-2.59 2.59V3h-2v10l-2.59-2.58L6 11.75 12 17.75l4-6zM4 19h16v2H4z"></path></svg>
    </div>

    <div class="ui-overlay">
        <div class="controls" id="controls">
            <div class="controls-header" id="controlsHeader">
                <h3>Poly-Sim <span class="gpu-indicator" id="gpuIndicator">CPU</span></h3>
                <div class="header-buttons">
                    <div class="toggle-btn" id="fullscreenBtn"></div>
                    <div class="toggle-btn" id="toggleBtn">▼</div>
                </div>
            </div>
            
            <div class="controls-content">
                <div class="section">
                    <div class="section-title">Simulation Mode</div>
                    <div class="preset-selector">
                        <div class="preset-btn physarum active" data-preset="physarum">Physarum</div>
                        <div class="preset-btn plasma" data-preset="plasma">Plasma</div>
                        <div class="preset-btn neural" data-preset="neural">Neural</div>
                        <div class="preset-btn scientific" data-preset="scientific">Scientific</div>
                    </div>
                    <div class="color-mode-selector">
                        <div class="color-mode-btn active" data-mode="natural">Natural</div>
                        <div class="color-mode-btn" data-mode="scientific">Analysis</div>
                        <div class="color-mode-btn" data-mode="thermal">Thermal</div>
                        <div class="color-mode-btn" data-mode="neon">Neon</div>
                    </div>
                </div>

<!-- ENTIRE NEW start SECTION -->
<div class="section">
    <div class="section-title">Agent Initialization</div>
    <div class="control-group">
        <label for="initPattern">Placement Pattern</label>
            <select id="initPattern">
            <option value="central-circle">Central Circle</option>
            <option value="random-circles">Multiple Random Circles</option>
            <option value="grid">Grid of Circles</option>
            <option value="ring">Ring of Circles</option>
            <option value="line-left">Line (Left Edge)</option>
            <option value="noise">Noise Scatter</option>
            <option value="from-mask">From Mask Edges</option>
        </select>
    </div>
    <div class="control-group">
        <label>Pattern Detail <span id="patternDetailValue">5</span></label>
        <input type="range" class="slider" id="patternDetail" min="1" max="20" value="5" step="1">
    </div>
    <div class="checkbox-group" style="justify-content: center;">
        <input type="checkbox" id="randomizeSizeToggle">
        <label for="randomizeSizeToggle">Randomize Sub-Pattern Size</label>
    </div>
</div>

                <div class="section">
                    <div class="section-title">Interaction Tools</div>
                    <p style="font-size: 10px; opacity: 0.7; margin-bottom: 10px;">Select a tool to use on the canvas.</p>
                    <div class="button-grid three-col">
                        <div class="action-btn" id="tool-spawn" onclick="setBrushMode('spawn')">Spawn Agents</div>
                        <div class="action-btn" id="tool-source" onclick="setBrushMode('source')">Place Source</div>
                        <div class="action-btn" id="tool-sink" onclick="setBrushMode('sink')">Place Sink</div>
                    </div>
                    <div class="button-grid" style="margin-top: 8px;">
                        <div class="action-btn reset-btn" onclick="clearSourcesAndSinks()">Clear Sources/Sinks</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="section-title">Environment</div>
                    <div class="checkbox-group" style="margin-bottom: 15px;"><input type="checkbox" id="hardBoundariesToggle"><label for="hardBoundariesToggle">Use Hard Boundaries</label></div>
                    <div class="file-input-wrapper"><input type="file" class="file-input" id="maskInput" accept="image/*"><div class="file-input-display">Load Environment Mask</div></div>


<div class="checkbox-group" style="justify-content: center; margin-bottom: 10px;">
    <input type="checkbox" id="maskAspectRatioToggle" checked>
    <label for="maskAspectRatioToggle">Keep Image Aspect Ratio</label>
</div>
                    <div class="button-grid three-col"><div class="action-btn maze-btn" onclick="generateMaze()">Gen Maze</div><div class="action-btn maze-btn" onclick="clearMask()">Clear</div><div class="action-btn maze-btn" onclick="invertMask()">Invert</div></div>
                </div>
                
                <div class="section">
                    <div class="section-title">Dynamic Environment</div>
                     <div class="checkbox-group"><input type="checkbox" id="animateSourcesToggle"><label for="animateSourcesToggle">Animate Sources & Sinks</label></div>
                     <div class="checkbox-group"><input type="checkbox" id="animateWormholesToggle"><label for="animateWormholesToggle">Animate Wormholes</label></div>
                     <div class="checkbox-group"><input type="checkbox" id="animateMaskToggle"><label for="animateMaskToggle">Animate (Shift) Mask</label></div>
                </div>

                <div class="section">
                    <div class="section-title">Visualizations & Forces</div>
                    <div class="checkbox-group"><input type="checkbox" id="flowFieldToggle"><label for="flowFieldToggle">Show Flow Vector Field</label></div>
                    <div class="control-group">
                        <label>Global Flow X (Wind) <span id="globalFlowXValue">0.0</span></label>
                        <input type="range" class="slider" id="globalFlowX" min="-1.0" max="1.0" value="0.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label>Global Flow Y (Wind) <span id="globalFlowYValue">0.0</span></label>
                        <input type="range" class="slider" id="globalFlowY" min="-1.0" max="1.0" value="0.0" step="0.1">
                    </div>
                </div>

                <div class="section">
                    <div class="section-title">Geometric Criticality</div>
                    <div class="file-input-wrapper"><input type="file" class="file-input" id="curvatureMapInput" accept="image/*"><div class="file-input-display">Load Curvature Map</div></div>

<div class="control-group" style="margin-bottom: 20px;">
    <label style="margin-bottom: 10px;">Data-Driven Color Mode</label>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
        <div class="checkbox-group"><input type="radio" name="dataViz" id="viz-none" checked><label for="viz-none">Default</label></div>
        <div class="checkbox-group"><input type="radio" name="dataViz" id="viz-age"><label for="viz-age">Agent Age</label></div>
        <div class="checkbox-group"><input type="radio" name="dataViz" id="viz-recency"><label for="viz-recency">Recency</label></div>
        <div class="checkbox-group"><input type="radio" name="dataViz" id="viz-direction"><label for="viz-direction">Direction</label></div>
    </div>
</div>                    
<!-- ADD THIS BLOCK -->
<div class="checkbox-group" style="justify-content: center; margin-bottom: 10px;">
    <input type="checkbox" id="curvatureAspectRatioToggle" checked>
    <label for="curvatureAspectRatioToggle">Keep Image Aspect Ratio</label>
</div>
<!-- END OF BLOCK TO ADD -->
                    
                    <div class="button-grid" style="margin-top: -4px; margin-bottom: 10px;"><div class="action-btn maze-btn" onclick="clearCurvatureMap()">Clear Map</div></div>
                    <div class="checkbox-group"><input type="checkbox" id="curvatureToggle"><label for="curvatureToggle">Enable Curvature Field</label></div>
                    <div class="control-group"><label>Curvature Strength <span id="curvatureStrengthValue">0.5</span></label><input type="range" class="slider" id="curvatureStrength" min="0.1" max="2.0" value="0.5" step="0.1"></div>
                    <div class="control-group">
                        <label>Wormhole Size (Radius) <span id="wormholeSizeValue">15</span></label>
                        <input type="range" class="slider" id="wormholeSize" min="5" max="60" value="15" step="1">
                    </div>
                    <div class="button-grid"><div class="action-btn maze-btn" onclick="setWormholeMode(true)">Place Wormholes</div><div class="action-btn maze-btn" onclick="clearWormholes()">Clear Wormholes</div></div>
                </div>
                
                <div class="section">
                    <div class="section-title">Performance & Free Energy</div>
                    <div class="checkbox-group"><input type="checkbox" id="gpuToggle"><label for="gpuToggle">GPU Acceleration <span id="gpuStatus">(Checking...)</span></label></div>
                    <div class="control-group"><label>Network Efficiency <span id="efficiencyValue">0.00</span></label></div>
                    <div class="control-group"><label>Agent Count <span id="agentCountValue">50000</span></label><input type="range" class="slider" id="agentCount" min="5000" max="100000" value="50000" step="5000"></div>
                </div>
                
                <div class="section">
                    <div class="section-title">Feedback Loop (R-D)</div>
                    <div class="control-group"><label>Sensor Angle <span id="sensorAngleValue">22.5°</span></label><input type="range" class="slider" id="sensorAngle" min="5" max="90" value="22.5" step="2.5"></div>
                    <div class="control-group"><label>Decay Rate <span id="decayRateValue">0.980</span></label><input type="range" class="slider" id="decayRate" min="0.900" max="0.999" value="0.980" step="0.001"></div>
                    <div class="control-group"><label>Deposit Strength <span id="depositStrengthValue">0.10</span></label><input type="range" class="slider" id="depositStrength" min="0.01" max="0.5" value="0.10" step="0.01"></div>
                    <div class="control-group"><label>Speed <span id="speedValue">1.0</span></label><input type="range" class="slider" id="speed" min="0.1" max="5.0" value="1.0" step="0.1"></div>
                </div>

<!-- REPLACE THE OLD "Neural Features" SECTION WITH THIS -->
<div class="section">
    <div class="section-title">Neural Activity</div>
    <div class="checkbox-group" style="margin-bottom: 15px;">
        <input type="checkbox" id="neuronFiring">
        <label for="neuronFiring">Enable Neural Activity</label>
    </div>
    
    <div class="control-group">
        <label for="firingMode">Firing Condition</label>
        <select id="firingMode" style="width: 100%; padding: 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; color: white;">
            <option value="random">Random Chance</option>
            <option value="junction">At Junctions</option>
            <option value="oscillator">Periodic (Oscillator)</option>
        </select>
    </div>

    <div class="control-group">
        <label>Firing Rate / Period <span id="firingRateValue">0.020</span></label>
        <input type="range" class="slider" id="firingRate" min="0.001" max="0.1" value="0.02" step="0.001">
    </div>

    <div class="checkbox-group" style="margin-top: 15px; margin-bottom: 15px;">
        <input type="checkbox" id="signalPropagation" checked>
        <label for="signalPropagation">Enable Signal Propagation</label>
    </div>

    <div class="control-group">
        <label>Signal Speed <span id="signalSpeedValue">2.0</span></label>
        <input type="range" class="slider" id="signalSpeed" min="0.5" max="5.0" value="2.0" step="0.1">
    </div>
    <div class="control-group">
        <label>Signal Duration <span id="signalDurationValue">150</span></label>
        <input type="range" class="slider" id="signalDuration" min="20" max="500" value="150" step="10">
    </div>
</div>                

                <div class="button-grid"><div class="action-btn reset-btn" onclick="resetSimulation()">Reset</div><div class="action-btn pause-btn" onclick="togglePause()">Pause</div></div>
                
                <div class="version-info"><a href="https://github.io/sandner-art/Poly-Sim" target="_blank">Poly-Sim</a> v1.0.0<br>© Daniel Sandner • <a href="https://sandner.art" target="_blank">sandner.art</a></div>
            </div>
        </div>
        <div class="fps-counter" id="fpsCounter">60 FPS</div>
        <div class="info-panel" id="infoPanel"><strong>Welcome to Poly-Sim v1.0!</strong><br>Explore new visualization and dynamic environment features.<br><small>Tap here to hide • Tap controls to collapse</small></div>
    </div>


    <script>
        // --- GLOBAL VARIABLES ---
        let canvas, gl, ctx;
        let graphCanvas, graphCtx;
        let width, height;
        let animationId;
        let isPaused = false;
        let useGPU = false;
        let isVortexing = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let currentColorMode = 'natural';

let gpu;
let gpuUpdateField;
let gpuUpdateAgents;
let agentDataTexture; // We will store agent data in a texture        

        let agents = [];
        let conductivityField = [], tempField = [];
        let maskField = [], rawMaskField = [];
        let firingField = [];
        let curvatureField = [];
        let wormholes = [];

        let signals = []; // Array to hold active signal neuron objects
        let signalField = []; // Array for the visual trail of signals

        let ageField = [], directionField = [], recencyField = [];
        let externalForceField = { x: [], y: [] };

        let sources = [], sinks = [];
        let flowFieldX = [], flowFieldY = [];

        let hasMask = false, hasCurvatureMap = false;
        let useHardBoundaries = false;
        let brushMode = 'spawn';
        let wormholePlacingMode = false, tempWormhole = null;
        let isGraphVisible = false;
        let isFlowVisible = false;
        let globalFlow = { x: 0, y: 0 };
        let dynamicEnv = { animateSources: false, animateMask: false, animateWormholes: false }; // animateWormholes
        let maskOffset = { x: 0, y: 0 };

        let gpuSupported = false;
        
        let frameCount = 0, lastTime = 0, fps = 60;
        let lastEfficiencyUpdateTime = 0;
        let lastAnalyticsTime = 0;
        let analyticsData = { efficiency: [], conductivity: [], agents: [] };
        
        let params = {
            agentCount: 50000, sensorAngle: 22.5 * Math.PI / 180, sensorDistance: 9.0, stepSize: 1.0, decayRate: 0.980,
            depositStrength: 0.10, speed: 1.0, diffusionRate: 0.1, neuronFiring: false, firingRate: 0.02, useCurvature: false, curvatureStrength: 0.5
        };
        const presets = {
            physarum: { agentCount: 50000, sensorAngle: 22.5 * Math.PI / 180, decayRate: 0.980, depositStrength: 0.10, speed: 1.0, diffusionRate: 0.3 },
            plasma: { agentCount: 5000, sensorAngle: 45 * Math.PI / 180, decayRate: 0.950, depositStrength: 0.20, speed: 2.5, diffusionRate: 0.1 },
            neural: { agentCount: 30000, sensorAngle: 30 * Math.PI / 180, decayRate: 0.995, depositStrength: 0.05, speed: 0.8, diffusionRate: 0.05 },
            scientific: { agentCount: 60000, sensorAngle: 35 * Math.PI / 180, decayRate: 0.985, depositStrength: 0.15, speed: 1.2, diffusionRate: 0.2 }
        };
        let currentPreset = 'physarum';
        const colorModes = { natural: { physarum: { color1: [0.05, 0.02, 0.0], color2: [0.4, 0.8, 0.2], color3: [0.9, 0.9, 0.4] }, plasma: { color1: [0.0, 0.0, 0.1], color2: [0.3, 0.1, 0.8], color3: [0.9, 0.7, 1.0] }, neural: { color1: [0.0, 0.05, 0.1], color2: [0.0, 0.4, 0.8], color3: [0.3, 0.8, 1.0] }, scientific: { color1: [0.1, 0.1, 0.1], color2: [0.8, 0.4, 0.0], color3: [1.0, 0.8, 0.2] } }, scientific: { physarum: { color1: [0.0, 0.0, 0.2], color2: [0.0, 0.8, 0.8], color3: [1.0, 1.0, 0.0] }, plasma: { color1: [0.2, 0.0, 0.0], color2: [0.8, 0.0, 0.8], color3: [1.0, 0.5, 0.0] }, neural: { color1: [0.0, 0.0, 0.0], color2: [0.0, 1.0, 0.0], color3: [1.0, 0.0, 0.0] }, scientific: { color1: [0.0, 0.0, 0.0], color2: [0.5, 0.5, 0.5], color3: [1.0, 1.0, 1.0] } }, thermal: { physarum: { color1: [0.0, 0.0, 0.2], color2: [0.8, 0.0, 0.0], color3: [1.0, 1.0, 0.0] }, plasma: { color1: [0.0, 0.0, 0.0], color2: [0.5, 0.0, 0.5], color3: [1.0, 0.0, 1.0] }, neural: { color1: [0.0, 0.0, 0.4], color2: [0.0, 0.5, 1.0], color3: [1.0, 1.0, 1.0] }, scientific: { color1: [0.0, 0.0, 0.5], color2: [1.0, 0.5, 0.0], color3: [1.0, 1.0, 0.5] } }, neon: { physarum: { color1: [0.1, 0.0, 0.1], color2: [0.0, 1.0, 0.5], color3: [0.5, 1.0, 1.0] }, plasma: { color1: [0.1, 0.0, 0.2], color2: [1.0, 0.0, 1.0], color3: [0.0, 1.0, 1.0] }, neural: { color1: [0.0, 0.1, 0.2], color2: [0.0, 1.0, 0.0], color3: [1.0, 1.0, 0.0] }, scientific: { color1: [0.2, 0.0, 0.2], color2: [1.0, 0.0, 0.0], color3: [0.0, 0.0, 1.0] } } };
        
class Agent {
    /**
     * The Agent constructor initializes an agent with a position, angle, and age.
     */
    constructor(x, y, angle) {
        this.x = x || Math.random() * width;
        this.y = y || Math.random() * height;
        this.angle = angle || Math.random() * Math.PI * 2;
        this.dx = Math.cos(this.angle);
        this.dy = Math.sin(this.angle);
        this.age = 0; // Agents now track their age in frames.
    }

    /**
     * The fire method creates a visual splash and launches a propagating signal.
     */
    fire() {
        // 1. Create the local "splash" effect in the firingField
        const fireRadius = 5;
        for (let dy = -fireRadius; dy <= fireRadius; dy++) {
            for (let dx = -fireRadius; dx <= fireRadius; dx++) {
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist <= fireRadius) {
                    const fx = Math.floor(this.x + dx);
                    const fy = Math.floor(this.y + dy);
                    if (fx >= 0 && fx < width && fy >= 0 && fy < height) {
                        const index = fy * width + fx;
                        const strength = (1 - dist / fireRadius) * 0.3;
                        firingField[index] = Math.min(1.0, (firingField[index] || 0) + strength);
                    }
                }
            }
        }
        // 2. Launch a propagating signal object if enabled
        if (document.getElementById('signalPropagation').checked && signals.length < 500) {
            signals.push(new Signal(this.x, this.y, this.angle));
        }
    }

    /**
     * The update method contains the core logic for agent movement, sensing, and interaction.
     */
    update() {
        // --- WORMHOLE LOGIC ---
        for (const pair of wormholes) {
            for (let i = 0; i < 2; i++) {
                const w = pair[i];
                if (Math.sqrt((this.x - w.x) ** 2 + (this.y - w.y) ** 2) < w.radius) {
                    const otherW = pair[1 - i];
                    this.x = otherW.x;
                    this.y = otherW.y;
                    this.angle += (Math.random() - 0.5) * 0.2;
                    break;
                }
            }
        }

    // --- EXTERNAL FORCES AND MOVEMENT ---

    // --- RE-INSERTED VORTEX LOGIC STARTS HERE ---
    const ix = Math.floor(this.x);
    const iy = Math.floor(this.y);
    if (ix >= 0 && ix < width && iy >= 0 && iy < height) {
        const forceIndex = iy * width + ix;
        const forceX = externalForceField.x[forceIndex] || 0;
        const forceY = externalForceField.y[forceIndex] || 0;
        if (forceX !== 0 || forceY !== 0) {
            const forceAngle = Math.atan2(forceY, forceX);
            // This is the line that blends the agent's angle with the vortex's angle
            this.angle = this.angle * 0.9 + forceAngle * 0.1;
        }
    }
    // --- RE-INSERTED VORTEX LOGIC ENDS HERE ---

    if (params.useCurvature) { const grad = sampleCurvatureGradient(this.x, this.y); this.angle += params.curvatureStrength * (this.dx * grad.y - this.dy * grad.x) * 0.1; }
    
    this.dx = Math.cos(this.angle);
    this.dy = Math.sin(this.angle);
    
    if (globalFlow.x !== 0 || globalFlow.y !== 0) {
        this.dx = this.dx * 0.95 + globalFlow.x * 0.05; this.dy = this.dy * 0.95 + globalFlow.y * 0.05;
        const speed = Math.sqrt(this.dx*this.dx + this.dy*this.dy); if(speed > 0){ this.dx /= speed; this.dy /= speed; }
        this.angle = Math.atan2(this.dy, this.dx);
    }
    let newX = this.x + this.dx * params.stepSize * params.speed;
    let newY = this.y + this.dy * params.stepSize * params.speed;
    
    // --- BOUNDARY AND MASK COLLISION ---
    if (hasMask && sampleMask(newX, newY) < 0.5) {
         this.angle += (Math.random() - 0.5) * Math.PI * 0.5;
    } else {
        this.x = (newX + width) % width;
        this.y = (newY + height) % height;
    }

        // --- DEPOSITING DATA AND INCREMENTING AGE ---
        this.age++; // Increment agent's age each frame
        const floorX = Math.floor(this.x);
        const floorY = Math.floor(this.y);
        depositAt(floorX, floorY, params.depositStrength);

        if (floorX >= 0 && floorX < width && floorY >= 0 && floorY < height) {
            const index = floorY * width + floorX;
            // Deposit data for visualizations
            ageField[index] = this.age;
            directionField[index] = this.angle / (Math.PI * 2); // Normalize angle to [0, 1]
            recencyField[index] = 1.0; // Mark this spot as recently active
        }

        // --- NEW, IMPROVED NEURAL FIRING LOGIC ---
        if (params.neuronFiring) {
            const firingMode = document.getElementById('firingMode').value;
            const firingRate = parseFloat(document.getElementById('firingRate').value);
            let shouldFire = false;

            switch (firingMode) {
                case 'random':
                    shouldFire = Math.random() < firingRate;
                    break;
                case 'junction':
                    // Fire if all three forward sensors detect a strong path
                    if (centerVal > 0.2 && leftVal > 0.15 && rightVal > 0.15) {
                        shouldFire = Math.random() < firingRate * 5.0; // More likely at junctions
                    }
                    break;
                case 'oscillator':
                    // The rate slider now controls the period
                    const period = Math.floor(1 / (firingRate * 2));
                    if (this.age > 0 && this.age % period === 0) {
                        shouldFire = true;
                    }
                    break;
            }

            if (shouldFire) {
                this.fire();
            }
        }

        // --- FLOW FIELD DEPOSIT ---
        if (isFlowVisible) {
            const ix = Math.floor(this.x);
            const iy = Math.floor(this.y);
            if (ix >= 0 && ix < width && iy >= 0 && iy < height) {
                const index = iy * width + ix;
                flowFieldX[index] += this.dx;
                flowFieldY[index] += this.dy;
            }
        }
    }
}

class Signal {
    constructor(x, y, angle) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.speed = parseFloat(document.getElementById('signalSpeed').value) || 2.0;
        this.ttl = parseInt(document.getElementById('signalDuration').value) || 150; // Time to live in frames
    }

    update() {
        this.ttl--;

        // Signals move by sensing the path, just like agents but simpler
        const sensorDist = params.sensorDistance * 0.5;
        const sensorAngle = params.sensorAngle;
        
        const leftVal = sampleConductivity(this.x + Math.cos(this.angle - sensorAngle) * sensorDist, this.y + Math.sin(this.angle - sensorAngle) * sensorDist);
        const rightVal = sampleConductivity(this.x + Math.cos(this.angle + sensorAngle) * sensorDist, this.y + Math.sin(this.angle + sensorAngle) * sensorDist);
        const centerVal = sampleConductivity(this.x + Math.cos(this.angle) * sensorDist, this.y + Math.sin(this.angle) * sensorDist);
        
        if (centerVal > leftVal && centerVal > rightVal) { /* continue straight */ } 
        else if (leftVal > rightVal) { this.angle -= sensorAngle * 0.2; } 
        else if (rightVal > leftVal) { this.angle += sensorAngle * 0.2; }
        else { this.angle += (Math.random() - 0.5) * Math.PI * 0.25; } // Random turn if lost

        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;

        // Deposit its light into the signalField
        const ix = Math.floor(this.x);
        const iy = Math.floor(this.y);
        if (ix >= 0 && ix < width && iy >= 0 && iy < height) {
            const index = iy * width + ix;
            signalField[index] = 1.0; // Leave a bright, temporary trail
        }

        // Boundary wrap
        this.x = (this.x + width) % width;
        this.y = (this.y + height) % height;
    }
}        

        function sampleConductivity(x, y) { x = Math.floor((x + width) % width); y = Math.floor((y + height) % height); if (x < 0 || x >= width || y < 0 || y >= height) return 0; return conductivityField[y * width + x] || 0; }
        function sampleMask(x, y) { if (!hasMask) return 1.0; const ix = Math.floor((x + maskOffset.x + width) % width); const iy = Math.floor((y + maskOffset.y + height) % height); if (ix < 0 || ix >= width || iy < 0 || iy >= height) return 0.0; return maskField[iy * width + ix]; }
        function sampleCurvatureGradient(x, y) { x = Math.floor((x + width) % width); y = Math.floor((y + height) % height); const C = (v, max) => Math.max(0, Math.min(max - 1, v)); const x1 = C(x - 1, width), x2 = C(x + 1, width); const y1 = C(y - 1, height), y2 = C(y + 1, height); return { x: (curvatureField[y * width + x2] - curvatureField[y * width + x1]) / 2.0, y: (curvatureField[y2 * width + x] - curvatureField[y1 * width + x]) / 2.0 }; }
        function depositAt(x, y, strength) { if (x < 0 || x >= width || y < 0 || y >= height) return; const index = y * width + x; conductivityField[index] = Math.min(1.0, (conductivityField[index] || 0) + strength); }

        function initializeSimulation() {
            const dpr = window.devicePixelRatio || 1; const rect = canvas.getBoundingClientRect();
            let baseWidth = Math.min(rect.width * dpr, 1200); let baseHeight = Math.min(rect.height * dpr, 800);
            if (window.innerWidth < 768) { baseWidth = Math.min(baseWidth, 600); baseHeight = Math.min(baseHeight, 400); }
            const aspectRatio = rect.width / rect.height; if (aspectRatio > 1) { baseHeight = Math.floor(baseWidth / aspectRatio); } else { baseWidth = Math.floor(baseHeight * aspectRatio); }
            width = Math.max(1, baseWidth); height = Math.max(1, baseHeight);
            
            conductivityField = new Float32Array(width * height); tempField = new Float32Array(width * height); firingField = new Float32Array(width * height);

            signalField = new Float32Array(width * height);

            ageField = new Float32Array(width * height);
            directionField = new Float32Array(width * height);
            recencyField = new Float32Array(width * height);
            tempField = new Float32Array(width * height);
    
            flowFieldX = new Float32Array(width * height); flowFieldY = new Float32Array(width * height);
            externalForceField.x = new Float32Array(width * height);
            externalForceField.y = new Float32Array(width * height);
            if (!hasCurvatureMap) generateCurvatureField();
            
// --- THIS IS THE NEW, CORRECTED BLOCK ---
    agents = [];
    const pattern = document.getElementById('initPattern').value;
    const detail = parseInt(document.getElementById('patternDetail').value);
    const randomize = document.getElementById('randomizeSizeToggle').checked;

    let placementPoints = [];
    const centerX = width * 0.5;
    const centerY = height * 0.5;

    // 1. Generate a list of points (centers of circles) based on the pattern
    switch (pattern) {
        case 'central-circle':
            placementPoints.push({ x: centerX, y: centerY, radius: Math.min(width, height) * 0.3 });
            break;
        case 'random-circles':
            for (let i = 0; i < detail; i++) {
                placementPoints.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    radius: (randomize ? Math.random() * 80 : 50) + 20
                });
            }
            break;
        case 'grid':
            const gridSize = detail + 1;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    placementPoints.push({
                        x: (width / (gridSize + 1)) * (i + 1),
                        y: (height / (gridSize + 1)) * (j + 1),
                        radius: (randomize ? Math.random() * 40 : 30) + 10
                    });
                }
            }
            break;
        case 'ring':
            const ringRadius = Math.min(width, height) * 0.35;
            for (let i = 0; i < detail * 2; i++) {
                const angle = (i / (detail * 2)) * Math.PI * 2;
                placementPoints.push({
                    x: centerX + Math.cos(angle) * ringRadius,
                    y: centerY + Math.sin(angle) * ringRadius,
                    radius: (randomize ? Math.random() * 30 : 25) + 5
                });
            }
            break;
        case 'line-left':
             placementPoints.push({ x: 40, y: centerY, radius: height * (detail/20) });
             break;
        case 'noise':
            // This just scatters agents everywhere, respecting the mask.
            // The detail slider has no effect here.
            for (let i = 0; i < params.agentCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                if (!hasMask || sampleMask(x, y) >= 0.5) {
                    agents.push(new Agent(x, y, Math.random() * Math.PI * 2));
                } else { i--; }
            }
            return; // Exit early as agents are already placed
        case 'from-mask':
             if (hasMask) {
                // Find edges in the mask (where black meets white)
                for (let y = 1; y < height - 1; y++) {
                    for (let x = 1; x < width - 1; x++) {
                        const i = y * width + x;
                        if (maskField[i] > 0.5) { // Is a path
                            // Check neighbors for a wall
                            if (maskField[i-1] < 0.5 || maskField[i+1] < 0.5 || maskField[i-width] < 0.5 || maskField[i+width] < 0.5) {
                                if (Math.random() < 0.1) { // Sparsely sample edge points
                                     placementPoints.push({ x: x, y: y, radius: (randomize ? Math.random() * 15 : 10) + 5 });
                                }
                            }
                        }
                    }
                }
             }
             if (placementPoints.length === 0) { // Fallback if no mask or no edges
                placementPoints.push({ x: centerX, y: centerY, radius: Math.min(width, height) * 0.3 });
             }
             break;
    }

    // 2. Distribute agents among the generated placement points
    const agentsPerPoint = Math.floor(params.agentCount / placementPoints.length);
    for (const point of placementPoints) {
        for (let i = 0; i < agentsPerPoint; i++) {
            // Find a valid spot within the circle's radius
            let placed = false;
            let attempts = 0;
            while (!placed && attempts < 20) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * point.radius;
                const x = point.x + Math.cos(angle) * r;
                const y = point.y + Math.sin(angle) * r;

                if (!hasMask || sampleMask(x, y) >= 0.5) {
                    agents.push(new Agent(x, y, angle));
                    placed = true;
                }
                attempts++;
            }
        }
    }
}

        
        
function updateSimulation() {
    if (isPaused) return;
    handleSources(); // Sources/sinks are infrequent, keep on CPU for simplicity

    // (Your dynamic env and mask animation logic can stay here)
            if (dynamicEnv.animateSources) {
                const time = Date.now() * 0.0002;
                sources.forEach((s, i) => { s.x += Math.sin(time + i) * 0.5; s.y += Math.cos(time - i) * 0.5; });
                sinks.forEach((s, i) => { s.x += Math.cos(time + i * 2) * 0.4; s.y += Math.sin(time - i * 2) * 0.4; });
            }
            // --- wormholes ---
            if (dynamicEnv.animateWormholes) {
                const time = Date.now() * 0.0003;
                wormholes.forEach((pair, i) => {
                    // Animate both wormholes in a pair with slightly different patterns
                    const w1 = pair[0];
                    const w2 = pair[1];
                    w1.x = w1.origX + Math.sin(time + i) * 15; // Oscillate within a 15-pixel radius
                    w1.y = w1.origY + Math.cos(time + i) * 15;
                    w2.x = w2.origX + Math.cos(time + i * 0.5) * 10;
                    w2.y = w2.origY + Math.sin(time + i * 0.5) * 10;
                });
            }
            // --- END BLOCK wormholes ---            
            if (dynamicEnv.animateMask && hasMask) {
                maskOffset.x = (maskOffset.x + 0.5) % width;
                maskOffset.y = (maskOffset.y + 0.25) % height;
            }

    if (useGPU && gpuUpdateField) {
        // --- GPU PATH ---
        
        // TODO: Implement the GPU agent update kernel (more complex, see below)
        // For now, let's keep agents on the CPU to show the field update working
        const survivingAgents = [];
        for (const agent of agents) {
            agent.update();
            if (!handleSinks(agent)) {
                survivingAgents.push(agent);
            }
        }
        agents = survivingAgents;

        
        // Now, update the entire field on the GPU
        gpuUpdateField(conductivityField, width, height, params.decayRate, presets[currentPreset].diffusionRate);
        conductivityField = gpuUpdateField.getPixels(); // This is slow! We will optimize this.

    } else {
        // --- CPU PATH (Your original code) ---
        const survivingAgents = [];
        for (const agent of agents) {
            agent.update();
            if (!handleSinks(agent)) {
                survivingAgents.push(agent);
            }
        }
        agents = survivingAgents;

// --- ADD THIS BLOCK TO UPDATE SIGNALS ---
for (let i = signals.length - 1; i >= 0; i--) {
    signals[i].update();
    if (signals[i].ttl <= 0) {
        signals.splice(i, 1); // Remove dead signals
    }
}
for (let i = 0; i < signalField.length; i++) {
    signalField[i] *= 0.88; // Signal trail fades faster
}
// --- END BLOCK ---

    for (let i = 0; i < recencyField.length; i++) {
        recencyField[i] *= 0.92; // Recency fades relatively quickly
    }

    for (let i = 0; i < conductivityField.length; i++) {
            conductivityField[i] *= params.decayRate;
        }
        // (neuron firing and flow field logic can stay here for the CPU path)
        applyDiffusion();
    }
}

        function applyDiffusion() {
            const diffusion = presets[currentPreset].diffusionRate; if (diffusion === 0) return;
            for (let y = 1; y < height - 1; y++) { for (let x = 1; x < width - 1; x++) { const i = y * width + x; let sum = 0; sum += conductivityField[i - width] * 0.2; sum += conductivityField[i - 1] * 0.2; sum += conductivityField[i] * 0.2; sum += conductivityField[i + 1] * 0.2; sum += conductivityField[i + width] * 0.2; tempField[i] = conductivityField[i] * (1 - diffusion) + sum * diffusion; } }
            [conductivityField, tempField] = [tempField, conductivityField];
            for (let i = 0; i < externalForceField.x.length; i++) {
                externalForceField.x[i] *= 0.9;
                externalForceField.y[i] *= 0.9;
            }
        }

        function renderSimulation() {
            if (!canvas || !canvas.getContext) return;
            const ctx = canvas.getContext('2d');

    if (useGPU && gpuUpdateField) {
        // --- NEW: RENDER DIRECTLY FROM GPU KERNEL ---
        // This is the fastest way. No data transfer from GPU->CPU.
        const gpuCanvas = gpuUpdateField.canvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(gpuCanvas, 0, 0, canvas.width, canvas.height);
    } else {            


            const imageData = ctx.createImageData(width, height); const data = imageData.data;
            const colors = colorModes[currentColorMode][currentPreset];
const vizAge = document.getElementById('viz-age').checked;
const vizRecency = document.getElementById('viz-recency').checked;
const vizDirection = document.getElementById('viz-direction').checked;

// Helper function to convert HSL to RGB, for our direction map
// h, s, l are in [0,1]; r, g, b are in [0, 255]
function hslToRgb(h, s, l) {
    let r, g, b;
    if (s == 0) { r = g = b = l; } 
    else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return [r * 255, g * 255, b * 255];
}

for (let i = 0; i < conductivityField.length; i++) {
    const pixelIndex = i * 4;
    let r = 0, g = 0, b = 0;
    const baseIntensity = Math.pow(Math.min(1, conductivityField[i]), 0.5);

    if (baseIntensity < 0.01) { // If there is almost no trail, just draw black
        data[pixelIndex] = 0; data[pixelIndex + 1] = 0; data[pixelIndex + 2] = 0; data[pixelIndex + 3] = 255;
        continue;
    }

// --- ADD THIS ENTIRE `else if` BLOCK ---
else if (signalField[i] > 0.05) {
    // Propagating signals are a bright, electric cyan
    const t = Math.min(1, signalField[i] * 2.0);
    r = t * 180;
    g = t * 255;
    b = t * 255;
} 
// --- END BLOCK ---    
    else if (vizAge) {
        // Agent Age: Maps age from 0-1500 frames to a blue (young) -> yellow (mid) -> red (old) spectrum
        const age = ageField[i];
        const t = Math.min(1, age / 1500.0);
        if (t < 0.5) {
            r = (t * 2) * 255; g = (t * 2) * 255; b = (1 - t * 2) * 255;
        } else {
            r = 255; g = (1 - (t - 0.5) * 2) * 255; b = 0;
        }

    } else if (vizRecency) {
        // Recency: Maps activity from 0-1 to a black -> magenta -> white spectrum
        const t = Math.min(1, recencyField[i] * 3.0); // Multiply to make it brighter
        r = t * 255; g = t * 100; b = t * 255;

    } else if (vizDirection) {
        // Direction: Maps angle (0-1) to an HSL color wheel
        const hue = directionField[i];
        const lightness = 0.5 * baseIntensity + 0.2; // Brighter on stronger paths
        [r, g, b] = hslToRgb(hue, 1.0, lightness);

    } else {
        // Default Mode (your original logic)
        let intensity = baseIntensity;
        if (params.neuronFiring && firingField[i] > 0) {
            intensity = Math.min(1, intensity + firingField[i] * 0.5);
        }
        if (intensity < 0.5) {
            const t = intensity * 2;
            r = (colors.color1[0] * (1 - t) + colors.color2[0] * t) * 255;
            g = (colors.color1[1] * (1 - t) + colors.color2[1] * t) * 255;
            b = (colors.color1[2] * (1 - t) + colors.color2[2] * t) * 255;
        } else {
            const t = (intensity - 0.5) * 2;
            r = (colors.color2[0] * (1 - t) + colors.color3[0] * t) * 255;
            g = (colors.color2[1] * (1 - t) + colors.color3[1] * t) * 255;
            b = (colors.color2[2] * (1 - t) + colors.color3[2] * t) * 255;
        }
    }
    
    data[pixelIndex] = r;
    data[pixelIndex + 1] = g;
    data[pixelIndex + 2] = b;
    data[pixelIndex + 3] = 255;
}
            const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height; const tempCtx = tempCanvas.getContext('2d'); tempCtx.putImageData(imageData, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.imageSmoothingEnabled = false; ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            
            if (isFlowVisible) renderFlowField();
            
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#FF00FF';
            sources.forEach(s => { ctx.beginPath(); ctx.arc(s.x / width * canvas.width, s.y / height * canvas.height, 10, 0, 2*Math.PI); ctx.strokeStyle = '#00FFFF'; ctx.stroke(); });
            sinks.forEach(s => { ctx.beginPath(); ctx.arc(s.x / width * canvas.width, s.y / height * canvas.height, s.radius/height*canvas.height, 0, 2*Math.PI); ctx.strokeStyle = '#FF0055'; ctx.stroke(); });
        wormholes.forEach(pair => {
    pair.forEach(w => {
        ctx.beginPath();
        ctx.arc(w.x / width * canvas.width, w.y / height * canvas.height, w.radius, 0, 2 * Math.PI);
        ctx.stroke();
    });
    // Optional: draw a faint line connecting the pair
    ctx.beginPath();
    ctx.moveTo(pair[0].x / width * canvas.width, pair[0].y / height * canvas.height);
    ctx.lineTo(pair[1].x / width * canvas.width, pair[1].y / height * canvas.height);
    ctx.globalAlpha = 0.3;
    ctx.stroke();
    ctx.globalAlpha = 1.0;
});

// Draw the temporary wormhole if user is in the middle of placing a pair
if (tempWormhole) {
    ctx.beginPath();
    ctx.arc(tempWormhole.x / width * canvas.width, tempWormhole.y / height * canvas.height, tempWormhole.radius, 0, 2 * Math.PI);
    ctx.setLineDash([5, 5]); // Dashed line for temporary placement
    ctx.stroke();
    ctx.setLineDash([]);
}    
        }
    }


        function renderFlowField() {
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)"; ctx.lineWidth = 1;
            const gridSize = 20; const scale = 15;
            for (let y = 0; y < canvas.height; y += gridSize) { for (let x = 0; x < canvas.width; x += gridSize) {
                const simX = Math.floor(x / canvas.width * width); const simY = Math.floor(y / canvas.height * height);
                const index = simY * width + simX;
                const vx = flowFieldX[index]; const vy = flowFieldY[index];
                const mag = Math.sqrt(vx*vx + vy*vy);
                if (mag > 0.01) {
                    ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + vx * scale, y + vy * scale); ctx.stroke();
                }
            }}
        }
        
        function drawAnalyticsGraph() {
            graphCtx.clearRect(0, 0, graphCanvas.width, graphCanvas.height);
            const datasets = [ { data: analyticsData.efficiency, color: "#00FFFF", label: "Efficiency" }, { data: analyticsData.conductivity, color: "#FFAA00", label: "Conductivity" }, { data: analyticsData.agents, color: "#FF00FF", label: "Agents" } ];
            datasets.forEach((set, i) => {
                const data = set.data; if (data.length < 2) return;
                let maxVal = 0; for(const val of data) { if(val > maxVal) maxVal = val; } if (maxVal === 0) maxVal = 1;
                graphCtx.beginPath(); graphCtx.strokeStyle = set.color; graphCtx.lineWidth = 1.5;
                for (let j = 0; j < data.length; j++) {
                    const x = (j / (data.length - 1)) * graphCanvas.width;
                    const y = graphCanvas.height - (data[j] / maxVal) * (graphCanvas.height - 10);
                    if (j === 0) { graphCtx.moveTo(x, y); } else { graphCtx.lineTo(x, y); }
                }
                graphCtx.stroke();
                graphCtx.fillStyle = set.color; graphCtx.font = "10px monospace"; graphCtx.fillText(set.label, 5, 12 * (i + 1));
            });
        }
        
        function animate(currentTime) {
            frameCount++; if (currentTime - lastTime >= 1000) { fps = Math.round(frameCount * 1000 / (currentTime - lastTime)); document.getElementById('fpsCounter').textContent = fps + ' FPS'; frameCount = 0; lastTime = currentTime; }
            if (currentTime - lastEfficiencyUpdateTime > 500) { calculateEfficiency(); lastEfficiencyUpdateTime = currentTime; }
            
            if (isGraphVisible && currentTime - lastAnalyticsTime > 500) {
                const totalConductivity = conductivityField.reduce((a, b) => a + b, 0);
                analyticsData.efficiency.push(parseFloat(document.getElementById('efficiencyValue').textContent));
                analyticsData.conductivity.push(totalConductivity / (width*height));
                analyticsData.agents.push(agents.length / params.agentCount);
                if(analyticsData.efficiency.length > 100) { analyticsData.efficiency.shift(); analyticsData.conductivity.shift(); analyticsData.agents.shift(); }
                lastAnalyticsTime = currentTime;
            }

            updateSimulation(); renderSimulation();
            if (isGraphVisible) drawAnalyticsGraph();
            
            animationId = requestAnimationFrame(animate);
        }

        function applyVortex(screenX, screenY, strength, radius) {
            const rect = canvas.getBoundingClientRect();
            const simX = (screenX - rect.left) / canvas.width * width;
            const simY = (screenY - rect.top) / canvas.height * height;

            const startX = Math.max(0, Math.floor(simX - radius));
            const endX = Math.min(width, Math.floor(simX + radius));
            const startY = Math.max(0, Math.floor(simY - radius));
            const endY = Math.min(height, Math.floor(simY + radius));

            for(let y = startY; y < endY; y++){
                for(let x = startX; x < endX; x++){
                    const dx = x - simX;
                    const dy = y - simY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < radius) {
                        const force = (1 - dist / radius) * strength;
                        const index = y * width + x;
                        // Perpendicular vector for rotation
                        externalForceField.x[index] -= dy * force * 0.1;
                        externalForceField.y[index] += dx * force * 0.1;
                    }
                }
            }
        }

        function init() {
            canvas = document.getElementById('canvas'); ctx = canvas.getContext('2d');
            graphCanvas = document.getElementById('analyticsCanvas'); graphCtx = graphCanvas.getContext('2d');
            canvas.style.position = 'fixed'; canvas.style.top = '0'; canvas.style.left = '0'; canvas.style.width = '100vw'; canvas.style.height = '100vh';
            checkGPUSupport(); resize(); setupEventListeners(); animate(0);
            setTimeout(() => { document.getElementById('infoPanel').classList.add('hidden'); }, 5000);
        }
        
        function resize() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width; canvas.height = rect.height;
            initializeSimulation();
        }

function setupEventListeners() {
            window.addEventListener('resize', resize);
            let isDrawing = false;
            let activeTouches = new Map();
            let lastTouchEnd = 0;

            function isEventOnUI(event) {
                return event.target.closest && (event.target.closest('.controls') || event.target.closest('#fpsCounter') || event.target.closest('#graphToggleBtn'));
            }

            canvas.addEventListener('mousedown', (e) => {
                if (isEventOnUI(e)) return;
                e.preventDefault();

                if (e.button === 0) { // Left mouse button
                    isDrawing = true;
                    startDrawing(e.clientX, e.clientY);
                } else if (e.button === 1) { // Middle mouse button (scroll wheel click)
                    isVortexing = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });

            
            document.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    spawnAgentsAt(e.clientX, e.clientY);
                } else if (isVortexing) {
                    const dx = e.clientX - lastMouseX;
                    // The strength and direction of the vortex is determined by horizontal mouse movement
                    const strength = dx * 0.5; 
                    const radius = 80; // A good fixed radius for the mouse vortex

                    applyVortex(e.clientX, e.clientY, strength, radius);

                    // Update last mouse position for the next frame
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });
            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) {
                    isDrawing = false;
                }
                if (e.button === 1) {
                    isVortexing = false;
                }
            });
            document.addEventListener('mouseleave', () => {
                isDrawing = false;
                isVortexing = false;
            });            
            // --- TOUCH EVENTS ---
            document.addEventListener('touchstart', (e) => {
                if (isEventOnUI(e)) return;

                // Prevent default for all canvas touches
                e.preventDefault();

                // Update active touches
                for (let touch of e.changedTouches) {
                    activeTouches.set(touch.identifier, {x: touch.clientX, y: touch.clientY});
                }

                // --- VORTEX GESTURE INITIALIZATION ---
                if (activeTouches.size === 2) {
                    isDrawing = false; // Stop single-finger drawing
                    const touches = Array.from(activeTouches.values());
                    // Calculate the initial angle and store it as lastAngle
                    const initialAngle = Math.atan2(touches[1].y - touches[0].y, touches[1].x - touches[0].x);
                    for (let touch of activeTouches.values()) {
                        touch.lastAngle = initialAngle;
                    }
                } else if (activeTouches.size === 1) {
                    isDrawing = true;
                    startDrawing(Array.from(activeTouches.values())[0].x, Array.from(activeTouches.values())[0].y);
                }

            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                // Do nothing if touch is on UI OR if no canvas gesture is active
                if (isEventOnUI(e) || activeTouches.size === 0) return;
                
                e.preventDefault();

                // Update touch positions
                for (let touch of e.changedTouches) {
                    if (activeTouches.has(touch.identifier)) {
                        const oldTouch = activeTouches.get(touch.identifier);
                        activeTouches.set(touch.identifier, {...oldTouch, x: touch.clientX, y: touch.clientY});
                    }
                }
                
                if (isDrawing && activeTouches.size === 1 && brushMode === 'spawn') {
                    spawnAgentsAt(Array.from(activeTouches.values())[0].x, Array.from(activeTouches.values())[0].y);
                } 
                // --- CORRECT VORTEX LOGIC ---
                else if (activeTouches.size === 2) {
                    const touches = Array.from(activeTouches.values());
                    const t1 = touches[0];
                    const t2 = touches[1];

                    // 1. Get the angle from the previous frame (it's the same for both touches)
                    const lastAngle = t1.lastAngle;

                    // 2. Calculate the current angle
                    const currentAngle = Math.atan2(t2.y - t1.y, t2.x - t1.x);

                    // 3. Find the difference from the last frame
                    const angleDiff = currentAngle - lastAngle;

                    // 4. If there was a change, apply the vortex
                    if (Math.abs(angleDiff) > 0.01) { // Small threshold for stability
                        const centerX = (t1.x + t2.x) / 2;
                        const centerY = (t1.y + t2.y) / 2;
                        // Strength is proportional to the rotational speed
                        applyVortex(centerX, centerY, angleDiff * 5.0, 100);
                    }

                    // 5. CRITICAL: Update lastAngle for the next frame
                    for (let touch of activeTouches.values()) {
                        touch.lastAngle = currentAngle;
                    }
                }
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!isEventOnUI(e)) {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) e.preventDefault();
                    lastTouchEnd = now;
                }

                for(let touch of e.changedTouches) {
                    activeTouches.delete(touch.identifier);
                }
                
                // If we are back to one finger, resume drawing. Otherwise, stop all actions.
                if (activeTouches.size === 1) {
                    isDrawing = true;
                } else {
                    isDrawing = false;
                }
            });

            setupControlListeners();
        }
        
        function setupControlListeners() {
            document.getElementById('controlsHeader').addEventListener('click', (e) => { if (!e.target.closest('.header-buttons')) toggleControls(); });
            document.getElementById('toggleBtn').addEventListener('click', toggleControls);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenIcon);
            document.addEventListener('webkitfullscreenchange', updateFullscreenIcon);
            document.querySelectorAll('.preset-btn').forEach(btn => btn.addEventListener('click', () => setPreset(btn.dataset.preset)));
            document.querySelectorAll('.color-mode-btn').forEach(btn => btn.addEventListener('click', () => setColorMode(btn.dataset.mode)));

document.getElementById('initPattern').addEventListener('change', initializeSimulation);
document.getElementById('patternDetail').addEventListener('input', (e) => {
    document.getElementById('patternDetailValue').textContent = e.target.value;
    initializeSimulation();
});
document.getElementById('randomizeSizeToggle').addEventListener('change', initializeSimulation);            

            document.getElementById('gpuToggle').addEventListener('change', (e) => {
    useGPU = e.target.checked && gpuSupported;
    const gpuIndicator = document.getElementById('gpuIndicator');
    gpuIndicator.textContent = useGPU ? 'GPU' : 'CPU';
    gpuIndicator.className = useGPU ? 'gpu-indicator gpu-on' : 'gpu-indicator gpu-off';

    // Create the GPU kernels ON-DEMAND the first time the user toggles GPU on.
    if (useGPU && !gpuUpdateField) { // Check if kernels are not already created
        console.log("Creating GPU kernels...");
        createGPUKernels();
    }
});
            document.getElementById('hardBoundariesToggle').addEventListener('change', (e) => { useHardBoundaries = e.target.checked; if (hasMask) { processMask(); initializeSimulation(); } });
            document.getElementById('neuronFiring').addEventListener('change', (e) => params.neuronFiring = e.target.checked);
            document.getElementById('curvatureToggle').addEventListener('change', (e) => params.useCurvature = e.target.checked);
            document.getElementById('neuronFiring').addEventListener('change', (e) => params.neuronFiring = e.target.checked);
            document.getElementById('firingRate').addEventListener('input', (e) => {
                params.firingRate = parseFloat(e.target.value);
                updateSliderDisplays();
            });
            document.getElementById('graphToggleBtn').addEventListener('click', toggleAnalyticsGraph);
            document.getElementById('flowFieldToggle').addEventListener('change', e => isFlowVisible = e.target.checked);
            document.getElementById('animateSourcesToggle').addEventListener('change', e => dynamicEnv.animateSources = e.target.checked);
            document.getElementById('animateWormholesToggle').addEventListener('change', e => dynamicEnv.animateWormholes = e.target.checked);

            document.getElementById('animateMaskToggle').addEventListener('change', e => dynamicEnv.animateMask = e.target.checked);
            document.getElementById('agentCount').addEventListener('input', (e) => { params.agentCount = parseInt(e.target.value); updateSliderDisplays(); initializeSimulation(); });
            document.getElementById('sensorAngle').addEventListener('input', (e) => { params.sensorAngle = parseFloat(e.target.value) * Math.PI / 180; updateSliderDisplays(); });
            document.getElementById('decayRate').addEventListener('input', (e) => { params.decayRate = parseFloat(e.target.value); updateSliderDisplays(); });
            document.getElementById('depositStrength').addEventListener('input', (e) => { params.depositStrength = parseFloat(e.target.value); updateSliderDisplays(); });
            document.getElementById('speed').addEventListener('input', (e) => { params.speed = parseFloat(e.target.value); updateSliderDisplays(); });
            document.getElementById('curvatureStrength').addEventListener('input', (e) => { params.curvatureStrength = parseFloat(e.target.value); updateSliderDisplays(); });
            document.getElementById('wormholeSize').addEventListener('input', updateSliderDisplays);

            // --- ADD THESE NEW LISTENERS ---
            document.getElementById('signalSpeed').addEventListener('input', updateSliderDisplays);
            document.getElementById('signalDuration').addEventListener('input', updateSliderDisplays);
            // --- END OF NEW LISTENERS ---

            document.getElementById('globalFlowX').addEventListener('input', (e) => { globalFlow.x = parseFloat(e.target.value); updateSliderDisplays(); });
            document.getElementById('globalFlowY').addEventListener('input', (e) => { globalFlow.y = parseFloat(e.target.value); updateSliderDisplays(); });
            document.getElementById('maskInput').addEventListener('change', loadMaskFile);
            document.getElementById('curvatureMapInput').addEventListener('change', loadCurvatureMapFile);
            document.getElementById('infoPanel').addEventListener('click', () => document.getElementById('infoPanel').classList.add('hidden'));
            setBrushMode('spawn');
            updateFullscreenIcon();
        }
        
        function startDrawing(x, y) {
            const coords = { x: x / canvas.width * width, y: y / canvas.height * height };
            if (wormholePlacingMode) { placeWormhole(x, y); return; }
            switch (brushMode) {
                case 'source': sources.push({ x: coords.x, y: coords.y }); break;
                case 'sink': sinks.push({ x: coords.x, y: coords.y, radius: 25 }); break;
                case 'spawn': spawnAgentsAt(x, y); break;
            }
        }
        
        function spawnAgentsAt(screenX, screenY) {
            const coords = { x: screenX / canvas.width * width, y: screenY / canvas.height * height };
            const spawnCount = Math.min(100, Math.floor(params.agentCount * 0.002));
            for (let i = 0; i < spawnCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 20;
                const agentX = coords.x + Math.cos(angle) * radius;
                const agentY = coords.y + Math.sin(angle) * radius;
                const index = Math.floor(Math.random() * agents.length);
                if (index < agents.length) { agents[index] = new Agent(agentX, agentY, angle); }
            }
        }
        
        function calculateEfficiency() {
            let totalConductivity = 0, activeNodes = 0;
            for(let i = 0; i < conductivityField.length; i++){ if (conductivityField[i] > 0.01) { totalConductivity += conductivityField[i]; activeNodes++; } }
            const cost = totalConductivity + params.agentCount * 0.0001;
            const reward = activeNodes / (width * height);
            const efficiency = cost > 0 ? reward / cost * 1000 : 0;
            document.getElementById('efficiencyValue').textContent = efficiency.toFixed(2);
        }
        
        function updateSliderDisplays() {
            // --- Standard Parameters ---
            document.getElementById('agentCountValue').textContent = params.agentCount.toLocaleString();
            document.getElementById('sensorAngleValue').textContent = (params.sensorAngle * 180 / Math.PI).toFixed(1) + '°';
            document.getElementById('decayRateValue').textContent = params.decayRate.toFixed(3);
            document.getElementById('depositStrengthValue').textContent = params.depositStrength.toFixed(2);
            document.getElementById('speedValue').textContent = params.speed.toFixed(1);
            document.getElementById('curvatureStrengthValue').textContent = params.curvatureStrength.toFixed(1);
            document.getElementById('globalFlowXValue').textContent = globalFlow.x.toFixed(1);
            document.getElementById('globalFlowYValue').textContent = globalFlow.y.toFixed(1);
            document.getElementById('patternDetailValue').textContent = document.getElementById('patternDetail').value;

            // --- ADDED: Neural Activity Parameters ---
            // Ensure the neural sliders are present before trying to read them
            const firingRateSlider = document.getElementById('firingRate');
            if (firingRateSlider) {
                document.getElementById('firingRateValue').textContent = parseFloat(firingRateSlider.value).toFixed(3);
            }
            const signalSpeedSlider = document.getElementById('signalSpeed');
            if (signalSpeedSlider) {
                document.getElementById('signalSpeedValue').textContent = parseFloat(signalSpeedSlider.value).toFixed(1);
            }
            const signalDurationSlider = document.getElementById('signalDuration');
            if (signalDurationSlider) {
                document.getElementById('signalDurationValue').textContent = signalDurationSlider.value;
            }
            const wormholeSizeSlider = document.getElementById('wormholeSize');
            if (wormholeSizeSlider) {
                document.getElementById('wormholeSizeValue').textContent = wormholeSizeSlider.value;
            }
        }

        function setPreset(presetName) {
            currentPreset = presetName;
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-preset="${presetName}"]`).classList.add('active');
            const preset = presets[presetName]; Object.assign(params, preset);
            document.getElementById('agentCount').value = preset.agentCount;
            document.getElementById('sensorAngle').value = preset.sensorAngle * 180 / Math.PI;
            document.getElementById('decayRate').value = preset.decayRate;
            document.getElementById('depositStrength').value = preset.depositStrength;
            document.getElementById('speed').value = preset.speed;
            updateSliderDisplays(); initializeSimulation();
        }

        function setColorMode(modeName) {
            currentColorMode = modeName;
            document.querySelectorAll('.color-mode-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-mode="${modeName}"]`).classList.add('active');
        }

        function resetSimulation() {
            conductivityField.fill(0); tempField.fill(0); firingField.fill(0);

            ageField.fill(0); directionField.fill(0); recencyField.fill(0);
            signals = []; signalField.fill(0);
            flowFieldX.fill(0); flowFieldY.fill(0);
            analyticsData = { efficiency: [], conductivity: [], agents: [] };
            clearSourcesAndSinks(); clearMask(); clearCurvatureMap(); clearWormholes();
            initializeSimulation();
        }

        function togglePause() {
            isPaused = !isPaused;
            const btn = document.querySelector('.pause-btn');
            btn.textContent = isPaused ? 'Resume' : 'Pause';
            btn.style.background = isPaused ? 'rgba(100, 255, 100, 0.3)' : 'rgba(255, 200, 100, 0.3)';
            btn.style.borderColor = isPaused ? 'rgba(100, 255, 100, 0.5)' : 'rgba(255, 200, 100, 0.5)';
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            const toggleBtn = document.getElementById('toggleBtn');
            controls.classList.toggle('collapsed');
            toggleBtn.innerHTML = controls.classList.contains('collapsed') ? '&#9652;' : '&#9662;';
        }

        function generateMaze() {
            const cellSize = 10;
            const mazeWidth = Math.floor(width / cellSize); const mazeHeight = Math.floor(height / cellSize);
            const maze = Array(mazeHeight).fill(0).map(() => Array(mazeWidth).fill(0));
            const stack = [];
            function getNeighbors(x, y) {
                const neighbors = []; const directions = [[0, -2], [2, 0], [0, 2], [-2, 0]];
                for (const [dx, dy] of directions) { const nx = x + dx; const ny = y + dy; if (nx >= 0 && nx < mazeWidth && ny >= 0 && ny < mazeHeight && maze[ny][nx] === 0) { neighbors.push([nx, ny]); } }
                return neighbors;
            }
            let currentX = Math.floor(Math.random() * (mazeWidth / 2)) * 2; let currentY = Math.floor(Math.random() * (mazeHeight / 2)) * 2;
            maze[currentY][currentX] = 1; stack.push([currentX, currentY]);
            while (stack.length > 0) {
                [currentX, currentY] = stack[stack.length - 1];
                const neighbors = getNeighbors(currentX, currentY);
                if (neighbors.length > 0) {
                    const [nextX, nextY] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    const wallX = currentX + (nextX - currentX) / 2; const wallY = currentY + (nextY - currentY) / 2;
                    maze[wallY][wallX] = 1; maze[nextY][nextX] = 1; stack.push([nextX, nextY]);
                } else { stack.pop(); }
            }
            rawMaskField = new Float32Array(width * height);
            for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const mazeX = Math.floor(x / cellSize); const mazeY = Math.floor(y / cellSize); rawMaskField[y * width + x] = maze[mazeY]?.[mazeX] ? 1.0 : 0.0; }}


            hasMask = true; processMask(); initializeSimulation();
        }

        function clearMask() { hasMask = false; rawMaskField = []; maskField = []; initializeSimulation(); }
        function invertMask() { if (!hasMask) return; for (let i = 0; i < rawMaskField.length; i++) { rawMaskField[i] = 1.0 - rawMaskField[i]; } processMask(); initializeSimulation(); }
        function loadMaskFile(event) {
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
// --- WITH THIS NEW LOGIC ---
const keepAspect = document.getElementById('maskAspectRatioToggle').checked;
const tempCanvas = document.createElement('canvas');
tempCanvas.width = width;
tempCanvas.height = height;
const tempCtx = tempCanvas.getContext('2d');

// Fill background with black (impassable) before drawing
tempCtx.fillStyle = 'black';
tempCtx.fillRect(0, 0, width, height);

if (keepAspect) {
    const imgAspect = img.width / img.height;
    const canvasAspect = width / height;
    let drawWidth, drawHeight;

    if (imgAspect > canvasAspect) { // Image is wider than the canvas viewport
        drawWidth = width;
        drawHeight = width / imgAspect;
    } else { // Image is taller or has the same aspect ratio
        drawHeight = height;
        drawWidth = height * imgAspect;
    }
    const x = (width - drawWidth) / 2;
    const y = (height - drawHeight) / 2;
    tempCtx.drawImage(img, x, y, drawWidth, drawHeight);
} else {
    // Original behavior: stretch image to fill the canvas
    tempCtx.drawImage(img, 0, 0, width, height);
}

const imageData = tempCtx.getImageData(0, 0, width, height);
const data = imageData.data;
rawMaskField = new Float32Array(width * height);
for (let i = 0; i < data.length; i += 4) {
    rawMaskField[i / 4] = (data[i] + data[i + 1] + data[i + 2]) / 3 / 255.0;
}
// --- END OF NEW LOGIC ---
                    hasMask = true; processMask(); initializeSimulation();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        function processMask() { if (!hasMask || rawMaskField.length === 0) return; maskField = new Float32Array(width * height); for (let i = 0; i < rawMaskField.length; i++) { maskField[i] = useHardBoundaries ? (rawMaskField[i] < 0.5 ? 0.0 : 1.0) : rawMaskField[i]; } }
        function generateCurvatureField() {
            curvatureField = new Float32Array(width * height); const scale = 10 / Math.min(width, height);
            for (let y = 0; y < height; y++) { for (let x = 0; x < width; x++) { const i = y * width + x; const v1 = Math.sin(x * scale * 2) * Math.cos(y * scale * 3); const v2 = Math.sin((x + y) * scale * 0.5) * Math.cos((x - y) * scale * 0.8); curvatureField[i] = v1 + v2; }}
        }
        function loadCurvatureMapFile(event) {
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
// --- WITH THIS NEW LOGIC ---
const keepAspect = document.getElementById('curvatureAspectRatioToggle').checked;
const tempCanvas = document.createElement('canvas');
tempCanvas.width = width;
tempCanvas.height = height;
const tempCtx = tempCanvas.getContext('2d');

// Fill background with medium gray (neutral curvature)
tempCtx.fillStyle = 'rgb(128, 128, 128)';
tempCtx.fillRect(0, 0, width, height);

if (keepAspect) {
    const imgAspect = img.width / img.height;
    const canvasAspect = width / height;
    let drawWidth, drawHeight;

    if (imgAspect > canvasAspect) { // Image is wider
        drawWidth = width;
        drawHeight = width / imgAspect;
    } else { // Image is taller
        drawHeight = height;
        drawWidth = height * imgAspect;
    }
    const x = (width - drawWidth) / 2;
    const y = (height - drawHeight) / 2;
    tempCtx.drawImage(img, x, y, drawWidth, drawHeight);
} else {
    // Original stretch-to-fill behavior
    tempCtx.drawImage(img, 0, 0, width, height);
}

const imageData = tempCtx.getImageData(0, 0, width, height);
const data = imageData.data;
curvatureField = new Float32Array(width * height);
for (let i = 0; i < data.length; i += 4) {
    curvatureField[i / 4] = ((data[i] + data[i + 1] + data[i + 2]) / 3 / 255.0) * 2.0 - 1.0;
}
// --- END OF NEW LOGIC ---
                    hasCurvatureMap = true; document.getElementById('curvatureToggle').checked = true; params.useCurvature = true;
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        function clearCurvatureMap() { hasCurvatureMap = false; generateCurvatureField(); }
        function setBrushMode(mode) {
            brushMode = mode;
            document.querySelectorAll('.action-btn[id^="tool-"]').forEach(btn => { btn.style.background = ''; btn.style.borderColor = ''; });
            const activeBtn = document.getElementById(`tool-${mode}`);
            if(activeBtn){ activeBtn.style.background = 'rgba(100, 200, 255, 0.3)'; activeBtn.style.borderColor = 'rgba(100, 200, 255, 0.5)'; }
            canvas.style.cursor = (mode === 'spawn') ? 'crosshair' : (mode === 'source') ? 'copy' : 'grab';
        }
        function handleSources() { sources.forEach(s => { if(Math.random() < 0.1 && agents.length < params.agentCount * 1.5) for(let i=0; i<5; i++) agents.push(new Agent(s.x, s.y)); }); }
        function handleSinks(agent) { for(const s of sinks) if(Math.sqrt((agent.x - s.x)**2 + (agent.y - s.y)**2) < s.radius) return true; return false; }
        function clearSourcesAndSinks() { sources = []; sinks = []; }
        function setWormholeMode(enabled) { wormholePlacingMode = enabled; canvas.style.cursor = enabled ? 'cell' : 'crosshair'; if (!enabled) tempWormhole = null; }
        function placeWormhole(screenX, screenY) {
            const coords = { x: screenX / canvas.width * width, y: screenY / canvas.height * height };
            
            // Read the current size from the slider
            const radius = parseFloat(document.getElementById('wormholeSize').value);

            const newWormhole = { 
                x: coords.x, 
                y: coords.y, 
                radius: radius, // Use the value from the slider
                origX: coords.x, 
                origY: coords.y 
            };

            if (!tempWormhole) {
                tempWormhole = newWormhole;
            } else {
                wormholes.push([tempWormhole, newWormhole]);
                tempWormhole = null;
                setWormholeMode(false);
            }
        }
        function clearWormholes() { wormholes = []; tempWormhole = null; setWormholeMode(false); }
        function toggleAnalyticsGraph() { isGraphVisible = !isGraphVisible; graphCanvas.classList.toggle('visible', isGraphVisible); }
function checkGPUSupport() {
    // With `defer`, we are now 100% sure the `GPU` object exists when this code runs.
    
    // Step 1: Check if the library thinks the browser is capable.
    gpuSupported = GPU.isGPUSupported;

    const gpuStatus = document.getElementById('gpuStatus');
    
    if (gpuSupported) {
        try {
            // Step 2: Try to actually initialize GPU.js.
            gpu = new GPU();
            gpuStatus.textContent = '(Available)';
        } catch (e) {
            // If initialization fails for any reason, report it.
            console.error("GPU.js failed to initialize:", e);
            gpuSupported = false;
            gpuStatus.textContent = '(Init Failed)';
            document.getElementById('gpuToggle').disabled = true;
        }
    } else {
        // If the browser isn't capable, report it.
        gpuStatus.textContent = '(Not Available)';
        document.getElementById('gpuToggle').disabled = true;
    }
}

function createGPUKernels() {
    // This kernel handles both decay and a 5-point diffusion pass
    gpuUpdateField = gpu.createKernel(function(field, width, height, decayRate, diffusionRate) {
        let sum = field[this.thread.y][this.thread.x];

        // 5-point Diffusion stencil
        const center = field[this.thread.y][this.thread.x] * 0.2;
        const up = field[this.thread.y + 1][this.thread.x] * 0.2;
        const down = field[this.thread.y - 1][this.thread.x] * 0.2;
        const left = field[this.thread.y][this.thread.x - 1] * 0.2;
        const right = field[this.thread.y][this.thread.x + 1] * 0.2;
        sum = up + down + left + right + center;

        const diffusedValue = (field[this.thread.y][this.thread.x] * (1 - diffusionRate)) + (sum * diffusionRate);

        // Apply decay and clamp the value between 0 and 1
        return Math.min(1.0, diffusedValue * decayRate);
    }).setOutput([width, height])
      .setGraphical(true); // Output a texture we can render directly
}        
        function toggleFullscreen() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen();
                else if (document.documentElement.webkitRequestFullscreen) document.documentElement.webkitRequestFullscreen();
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
                else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            }
        }
        function updateFullscreenIcon() {
            const fullscreenBtn = document.getElementById('fullscreenBtn'); if (!fullscreenBtn) return;
            const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement);
            fullscreenBtn.innerHTML = isFullscreen ? `<svg viewBox="0 0 24 24"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"/></svg>` : `<svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>`;
            fullscreenBtn.title = isFullscreen ? "Exit Fullscreen" : "Enter Fullscreen";
        }

        if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }


    </script>
</body>
</html>
